import * as path from 'path';
import * as fs from 'fs';
import { Migration, LoadedMigration } from './migration.interface';

/**
 * Pattern for timestamp-based migration filenames: YYYYMMDD-HHMMSS.ts
 * This is the recommended format used by scaffold, but not required.
 */
const TIMESTAMP_PATTERN = /^(\d{8}-\d{6})\.ts$/;

/**
 * Loads migration files from the filesystem.
 *
 * Migration files must:
 * - Be TypeScript files with .ts extension
 * - Export a default class/object implementing the Migration interface (up/down methods)
 *
 * Naming conventions (all supported):
 * - YYYYMMDD-HHMMSS.ts (recommended, generated by scaffold)
 * - 001_initial.ts, 002_add_users.ts (numbered)
 * - create_users.ts, add_posts.ts (descriptive)
 *
 * Files are sorted lexicographically, so use consistent naming for proper order.
 *
 * @example
 * ```typescript
 * const loader = new MigrationLoader('./migrations');
 * const migrations = await loader.loadAllMigrations();
 * ```
 */
export class MigrationLoader {
  constructor(private migrationsDirectory: string) {}

  /**
   * Extract a sort key from the filename.
   * For timestamp patterns, extracts the timestamp.
   * For other patterns, uses the filename without extension.
   */
  private extractSortKey(filename: string): string {
    const timestampMatch = filename.match(TIMESTAMP_PATTERN);
    if (timestampMatch) {
      return timestampMatch[1];
    }
    // Remove .ts extension for sorting
    return filename.replace(/\.ts$/, '');
  }

  /**
   * Get all migration files in the directory, sorted lexicographically.
   * Includes all .ts files in the directory.
   */
  async getMigrationFiles(): Promise<string[]> {
    const absoluteDir = this.getAbsoluteDirectory();

    if (!fs.existsSync(absoluteDir)) {
      return [];
    }

    const files = fs.readdirSync(absoluteDir);
    return files
      .filter(f => f.endsWith('.ts') && !f.endsWith('.d.ts'))
      .sort((a, b) => this.extractSortKey(a).localeCompare(this.extractSortKey(b)));
  }

  /**
   * Load a single migration file.
   *
   * Uses require() to load the TypeScript file, which works when running
   * with ts-node, tsx, or other TypeScript loaders.
   *
   * @param filename - The migration filename to load
   * @returns The loaded migration with metadata
   * @throws Error if the file doesn't exist or doesn't implement Migration
   */
  async loadMigration(filename: string): Promise<LoadedMigration> {
    const absoluteDir = this.getAbsoluteDirectory();
    const filePath = path.join(absoluteDir, filename);

    if (!filename.endsWith('.ts')) {
      throw new Error(
        `Invalid migration filename: ${filename}. Must be a .ts file`
      );
    }

    if (!fs.existsSync(filePath)) {
      throw new Error(`Migration file not found: ${filePath}`);
    }

    // Clear require cache to ensure fresh load (useful during development)
    delete require.cache[require.resolve(filePath)];

    // Dynamically require the migration file
    // This works with ts-node/tsx at runtime
    const module = require(filePath);
    const MigrationClass = module.default || module;

    // Instantiate if it's a class, otherwise use as-is (for object exports)
    let migration: Migration;
    try {
      migration = typeof MigrationClass === 'function'
        ? new MigrationClass()
        : MigrationClass;
    } catch (err) {
      throw new Error(
        `Failed to instantiate migration ${filename}: ${(err as Error).message}`
      );
    }

    // Validate migration has required methods
    if (typeof migration.up !== 'function') {
      throw new Error(
        `Migration ${filename} must export a class/object with an 'up' method`
      );
    }
    if (typeof migration.down !== 'function') {
      throw new Error(
        `Migration ${filename} must export a class/object with a 'down' method`
      );
    }

    // Extract timestamp if present, otherwise use sort key
    const sortKey = this.extractSortKey(filename);

    return {
      filename,
      timestamp: sortKey,
      migration,
      filePath,
    };
  }

  /**
   * Load all migrations from the directory, sorted lexicographically.
   * @returns Array of loaded migrations in order
   */
  async loadAllMigrations(): Promise<LoadedMigration[]> {
    const files = await this.getMigrationFiles();
    const migrations: LoadedMigration[] = [];

    for (const file of files) {
      const loaded = await this.loadMigration(file);
      migrations.push(loaded);
    }

    return migrations;
  }

  /**
   * Generate a new migration filename with the current timestamp.
   * Format: YYYYMMDD-HHMMSS.ts (recommended naming convention)
   *
   * @returns A new unique migration filename
   */
  generateFilename(): string {
    const now = new Date();
    const timestamp = [
      now.getFullYear().toString(),
      (now.getMonth() + 1).toString().padStart(2, '0'),
      now.getDate().toString().padStart(2, '0'),
      '-',
      now.getHours().toString().padStart(2, '0'),
      now.getMinutes().toString().padStart(2, '0'),
      now.getSeconds().toString().padStart(2, '0'),
    ].join('');

    return `${timestamp}.ts`;
  }

  /**
   * Get the absolute path to the migrations directory.
   * Resolves relative paths against process.cwd().
   */
  getAbsoluteDirectory(): string {
    return path.isAbsolute(this.migrationsDirectory)
      ? this.migrationsDirectory
      : path.resolve(process.cwd(), this.migrationsDirectory);
  }

  /**
   * Ensure the migrations directory exists.
   * Creates it (including parent directories) if it doesn't exist.
   */
  ensureDirectory(): void {
    const absoluteDir = this.getAbsoluteDirectory();
    if (!fs.existsSync(absoluteDir)) {
      fs.mkdirSync(absoluteDir, { recursive: true });
    }
  }
}
