## Bug Fixes

### `update()` with Navigation Properties in WHERE

Fixed `update()` not generating proper JOINs for navigation properties used in WHERE clauses. PostgreSQL UPDATE requires `FROM` clause for JOINs instead of standard JOIN syntax.

```typescript
// Before: Crashed with "missing FROM-clause entry for table"
// After: Correctly uses FROM clause to join related tables
await db.cartItems
  .where(p => and(
    eq(p.cart.uuid, cartId),
    isNull(p.cart.userId)
  ))
  .update({ cartId: newCartId });
```

### Multi-Level Navigation Properties in `returning()` Statements

Fixed multi-level navigation properties in `returning()` clauses crashing with "Cannot read properties of undefined". The fix ensures the schema registry is properly passed to navigation builders and that FK column lookups use the correct intermediate schemas.

```typescript
// Before: Crashed with "Cannot read properties of undefined (reading 'integrationConfig')"
// After: Correctly resolves multi-level navigation paths
const inserted = await db.orderTasks
  .insert({ orderId: order.id, taskId: task.id, sortOrder: 1 })
  .returning(ot => ({
    orderId: ot.orderId,
    taskTitle: ot.task!.title,
    levelName: ot.task!.level!.name,                    // 2-level navigation
    creatorUsername: ot.task!.level!.createdBy!.username, // 3-level navigation
  }));
```

This fix applies to all mutation methods with `returning()`:
- `insert().returning()`
- `insertBulk().returning()`
- `update().returning()`
- `delete().returning()`
- `upsertBulk().returning()`

### Nested Plain Objects in `returning()` Statements

Added support for nested plain objects in `returning()` clauses. You can now structure your return data with nested objects that contain navigation properties.

```typescript
// Now supported: nested objects with navigation fields
const inserted = await db.orderTasks
  .insert({ orderId: order.id, taskId: task.id, sortOrder: 1 })
  .returning(ot => ({
    orderId: ot.orderId,
    taskInfo: {
      title: ot.task!.title,
      priority: ot.task!.priority,
      level: {
        name: ot.task!.level!.name,
        creator: {
          username: ot.task!.level!.createdBy!.username,
          email: ot.task!.level!.createdBy!.email,
        },
      },
    },
  }));

// Returns: { orderId: 1, taskInfo: { title: '...', priority: '...', level: { name: '...', creator: { username: '...', email: '...' } } } }
```

### Collection Queries in `returning()` Statements

Added support for collection queries (`.toList()`, `.firstOrDefault()`) in `returning()` clauses. You can now fetch related collections as part of mutation return values.

```typescript
// Get user's posts as a collection in returning()
const updated = await db.users
  .where(u => eq(u.id, userId))
  .update({ age: 31 })
  .returning(u => ({
    id: u.id,
    username: u.username,
    posts: u.posts.select(p => ({
      title: p.title,
      views: p.views,
    })).toList(),
  }));

// Get the most popular post using firstOrDefault()
const updated = await db.users
  .where(u => eq(u.id, userId))
  .update({ age: 31 })
  .returning(u => ({
    id: u.id,
    topPost: u.posts
      .select(p => ({ title: p.title, views: p.views }))
      .orderBy(p => [[p.views, 'DESC']])
      .firstOrDefault(),
  }));

// Filter collections with .where()
const updated = await db.users
  .where(u => eq(u.id, userId))
  .update({ age: 31 })
  .returning(u => ({
    id: u.id,
    popularPosts: u.posts
      .where(p => gt(p.views, 100))
      .select(p => ({ title: p.title }))
      .toList(),
  }));
```

### Collection Queries Through Multi-Level Navigation in `returning()`

Fixed collection queries accessed through multi-level navigation paths (e.g., `order.user.posts`) in `returning()` clauses. The fix ensures:
1. Navigation joins leading to the collection's source table are properly detected and created
2. All table references in collection subqueries are rewritten to use the correct aliases from the main query's JOINs

```typescript
// Before: Crashed with "missing FROM-clause entry for table"
// After: Correctly joins through navigation path and rewrites table references
const inserted = await db.orderItems
  .insert({ orderId: order.id, productPriceId: price.id })
  .returning(oi => ({
    id: oi.id,
    // Collection accessed through multi-level navigation: orderItem -> productPrice -> product -> resort
    integrationDefs: oi.productPrice!.product!.resort!.productIntegrationDefinitions
      .select(pid => ({
        type: pid.integrationType,
        config: pid.config,
      }))
      .toList(),
  }));
```

### Full Change List
- Fixed `update()` to detect navigation property JOINs and use PostgreSQL `FROM` clause
- Fixed multi-level navigation in `returning()` by passing schemaRegistry to navigation builders
- Fixed FK column resolution to use correct intermediate schemas for multi-level joins
- Added support for nested plain objects in `returning()` with automatic reconstruction
- Added support for collection queries (`.toList()`, `.firstOrDefault()`) in `returning()` clauses
- Fixed collection queries through multi-level navigation paths in `returning()` clauses
- Added `rewriteCollectionTableReferences` to properly rewrite all table references in collection subqueries
- Added comprehensive tests for `update()` with navigation properties (5 tests)
- Added comprehensive tests for multi-level navigation in `returning()` (6 tests)
- Added tests for nested objects in `returning()` (2 tests)
- Added tests for collection queries in `returning()` (11 tests)
